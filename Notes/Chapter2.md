# 算法效率评估

渐近复杂度分析 asymptotic complexity analysis

复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。**它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。**

- “时间和空间资源”分别对应「时间复杂度 time complexity」和「空间复杂度 space complexity」。
- “随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。
- “时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。

# 迭代与递归

## 迭代

迭代是**重复执行某个任务的控制结构**

在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。

### for 循环

```c++
/* for 循环 */
int forLoop(int n)
{
    int res = 0;
    for (int i = 1; i <= n; i++)
    {
        res += i;
    }
    return res;
}
```

### while 循环

```c++
/* while 循环 */
int whileLoop(int n)
{
    int res = 0;
    int i = 1;
    while (i <= n)
    {
        res += i;
        i++;
    }
    return res;
}
```

### 双层循环

```c++
/* while 循环（两次更新）*/
int whileLoopII(int n)
{
    int res = 0;
    int i = 1;
    while (i <= n)
    {
        res += i;
        i += 1;
        i *= 2;
    }
    return res;
}

/* 双层 for 循环 */
std::string nestedForLoop(int n)
{
    std::string res = "";
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            res += "(" + std::to_string(i) + ", " + std::to_string(j) + ")";
            if (i != n || j != n) // check if it is a last iteration
            {
                res += ", ";
            }
            // std::string str1 = "(" + std::to_string(i);
            // std::string str2 = ", ";
            // std::string str3 = std::to_string(j) + "), ";

            // res += (str1 + str2 + str3);
        }
    }
    return res;
}

/*
 * std::stringstream可以减少内存分配和拷贝的次数，因为它会在内部维护一个缓冲区
 * 而不是每次都分配新的内存空间进行字符串拼接。
 * 使用<<操作符可以直接向std::stringstream中添加数据，使得代码更加清晰易读。
 * std::stringstream可以方便地进行不同类型的数据转换，例如将整数、浮点数等转换为字符串。
 */
std::string nestedForLoopII(int n)
{
    std::stringstream res;
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= n; j++)
        {
            res << "(" << i << ", " << j << ")";
            if (i != n || j != n) // check if it is a last iteration
            {
                res << ", ";
            }
        }
    }
    return res.str();
}
```

## 递归

递归通过函数调用自身来解决问题

递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。

归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。

三个要素

1. 终止条件：用于决定什么时候由“递”转“归”。
2. 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。
3. 返回结果：对应“归”，将当前递归层级的结果返回至上一层。

迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。

递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。

### 调用栈

递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。

- 函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，**递归通常比迭代更加耗费内存空间**
- 递归调用函数会产生额外的开销。因此**递归通常比循环的时间效率更低**

过深的递归可能导致栈溢出错误

### 尾递归

如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）

- 普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。
- 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。

个人想法：尾递归达到返回条件时，已经计算得到最后结果了，在归的过程中，结果的值是不改变的

普通递归和尾递归求和过程不太一样：

- 普通递归：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。
- 尾递归：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。
